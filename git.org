* github with CA problems soluation
** Make sure first that you have certificates installed on your Debian in /etc/ssl/certs.If not, reinstall them:
   sudo apt-get install --reinstall ca-certificates
** Since that package does not include root certificates, add:
  sudo mkdir /usr/local/share/ca-certificates/cacert.org
  sudo wget -P /usr/local/share/ca-certificates/cacert.org http://www.cacert.org/certs/root.crt http://www.cacert.org/certs/class3.crt
  sudo update-ca-certificates
** troubleshoot
ssh-keygen 產生出 id_rsa, id_rsa.pub, 已經都放到正確位置(.ssh), 但是連線時卻出現下述訊息:

Agent admitted failure to sign using the key


解法

於自己的機器上, 執行 ssh-add, 會出現下述訊息.

Identity added: /home/user/.ssh/id_rsa (/home/user/.ssh/id_rsa)
** Make sure your git does reference those CA:
  git config --global http.sslCAinfo /etc/ssl/certs/ca-certificates.crt
  
* git
	
If the add-apt-repository command doesn't work, you need to add the python-software-properties package first. Combined you would do:
sudo apt-get install software-properties-common
sudo apt-get install python-software-properties
sudo add-apt-repository ppa:git-core/ppa
sudo apt-get update
sudo apt-get install git
git --version

* github delete branch
     git push  origin:mqtls
  
* git submodule
     git submodule init
	 git submodule update

git clone git@github.com:nutzam/nutz --depth=1
or
--recursive

git merge --no-commint

git commit --amend --date="$date"

I tested in another repo already, the procedure works.
something like these:
git submodule init
git submodule sync
git submodule update --remote --merge

commit changes to submodule (push to submodule, then to superproject)
- cd to the submodule folder
- git add/commit
- cd to the superproject
- git add/commit
- git push --recurse-submodule=check/on-demand

A example of how I use git submodules.

Creates a new repo
Then clones another repo as submodule
Then we have that submodule use a tag called V3.1.2
And then we commit
And that looks a little bit like this:

git init 
vi README
git add README
git commit 
git submodule add git://github.com/XXXXX/xxx.yyyy.git stm32_std_lib
git status

git submodule init
git submodule update

cd stm32_std_lib/
git reset --hard V3.1.2 
cd ..
git commit -a

git submodule status 

* git diffall
使用git difftool （git mergetool）

git difftool 和 git mergetool是专门提供给我们以用自己的工具进行diff和merge的命令。只要配置一下就可以使用了：

git config --global diff.tool meld #配置默认的difftool
git config --global merge.tool meld #配置默认的mergetool

然后输入命令 git difftool HEAD HEAD^1 看看？
使用meld直接比较目录

虽然使用git difftool已经基本满足了我的需要，但还有个小问题：如果我要比较两次提交之间的差异时，difftool只能一个文件一个文件的比较，每次都要提 示你是否打开这个文件，然后打开meld进行比较，当你关闭meld后，才会提示下一个差异文件。这样非常浪费效率。能不能直接利用meld的目录比较能 力呢？

搜了一下，果然有人把脚本写好了： https://github.com/thenigan/git-diffall

也可以到这里下载： http://files.cnblogs.com/pengdonglin137/git-diffall-master.zip

下下来以后，进行如下配置：

git config --global diff.tool meld
git config --global alias.diffall /PATH/TO/YOUR/git-diffall

现在试试 git diffall HEAD HEAD^1 ？

多谢lxd提出遇到的问题与我分享，上述配置会遇到错误 “Expansion of alias ‘diffall’ failed; ‘/xxxx/git-diffall/git-diffall’ is not a git command”，最方便的解决方法就是创建一个软链接在你的PATH路径之一里，比如：

sudo ln -s /home/ubuntu/customization/os/git-diffall.sh /bin/git-diffall

然后配置

git config --global diff.tool meld #这一行必须配置，否则diffall不知道该使用哪个diff程序
git config –global alias.diffall git-diffall
 
* git checkout from
    git checkout tags/<tag_name> -b <branch_name>
    git checkout -b <branch_name> remotes/origin/***

* tags?
# list all tags
git tag

# list all tags with given pattern ex: v-
git tag --list 'v-*'
How to create tags?
There are 2 ways to create a tag:

# normal tag 
git tag 

# annotated tag
git tag -a

但是目前这个标签仅仅是提交到了本地git仓库.如何同步到远程代码库

tag 远程推送:

zhangzhi@moke:~/code/demo$git push origin --tags
这样我们就把本地版本推送到了远程代码仓库.



如果刚刚同步上去,你缺发现一个致命bug ,需要重新打版本,现在还为时不晚.



删除标签:

zhangzhi@moke:~/code/demo$git tag -d V1.2
到这一步我们只是删除了本地 V1.2的版本,可是线上V1.2的版本还是存在,如何办?

这时我们可以推送的空的同名版本到线下,达到删除线上版本的目标:

zhangzhi@moke:~/code/demo$git push origin :refs/tags/V1.2
这时本地和远程的 V1.2 版本已经被我们移除掉.



如何获取远程版本:

zhangzhi@moke:~/code/demo$git fetch origin tag V1.2

* git proxy
//通过 http 链接 clone 代码时走 socks5 代理
git config --global http.proxy "socks5://127.0.0.1:6666"
//通过 https 链接 clone 代码时走 socks5代理
git config --global https.proxy "socks5://127.0.0.1:6666"


# 这里必须是 github.com，因为这个跟我们 clone 代码时的链接有关
Host github.com
   # 如果用默认端口，这里是 github.com，如果想用443端口，这里就是 ssh.github.com 详见 https://help.github.com/articles/using-ssh-over-the-https-port/
   HostName github.com
   User git
   # 如果是 HTTP 代理，把下面这行取消注释，并把 proxyport 改成自己的 http 代理的端口
   # ProxyCommand socat - PROXY:127.0.0.1:%h:%p,proxyport=6667
   # 如果是 socks5 代理，则把下面这行取消注释，并把 6666 改成自己 socks5 代理的端口
   # ProxyCommand nc -v -x 127.0.0.1:6666 %h %p

终端 terminal
在 .bashrc 或 .zshrc 中设置如下内容

alias setproxy="export ALL_PROXY=socks5://127.0.0.1:1080"
alias unsetproxy="unset ALL_PROXY"
alias ip="curl -i http://ipinfo.io"

* setup git 
1) mkdir .ssh copy private key && chmod 400
2) sudo apt install git
3)  ssh-add ~/.ssh/id_
4) ssh -T git@github.com
